<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhetstester - Kortlek</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #2c3e50; }
        .test-suite {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-suite h2 {
            margin-top: 0;
            color: #34495e;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .test {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .test.pass { background: #d4edda; color: #155724; }
        .test.fail { background: #f8d7da; color: #721c24; }
        .summary {
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .summary.all-pass { background: #28a745; color: white; }
        .summary.has-fail { background: #dc3545; color: white; }
        .error-msg {
            font-size: 0.85rem;
            margin-top: 5px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>Enhetstester</h1>
    <div id="results"></div>
    <div id="summary"></div>

    <script>
        // Simple test framework
        let tests = [];
        let passed = 0;
        let failed = 0;

        function describe(suiteName, fn) {
            tests.push({ type: 'suite', name: suiteName });
            fn();
        }

        function it(testName, fn) {
            try {
                fn();
                tests.push({ type: 'test', name: testName, pass: true });
                passed++;
            } catch (error) {
                tests.push({ type: 'test', name: testName, pass: false, error: error.message });
                failed++;
            }
        }

        function expect(actual) {
            return {
                toBe(expected) {
                    if (actual !== expected) {
                        throw new Error(`FÃ¶rvÃ¤ntat ${JSON.stringify(expected)}, fick ${JSON.stringify(actual)}`);
                    }
                },
                toEqual(expected) {
                    if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                        throw new Error(`FÃ¶rvÃ¤ntat ${JSON.stringify(expected)}, fick ${JSON.stringify(actual)}`);
                    }
                },
                toBeGreaterThan(expected) {
                    if (!(actual > expected)) {
                        throw new Error(`FÃ¶rvÃ¤ntat ${actual} > ${expected}`);
                    }
                },
                toBeLessThan(expected) {
                    if (!(actual < expected)) {
                        throw new Error(`FÃ¶rvÃ¤ntat ${actual} < ${expected}`);
                    }
                },
                toContain(expected) {
                    if (!actual.includes(expected)) {
                        throw new Error(`FÃ¶rvÃ¤ntat att ${JSON.stringify(actual)} innehÃ¥ller ${JSON.stringify(expected)}`);
                    }
                },
                toHaveLength(expected) {
                    if (actual.length !== expected) {
                        throw new Error(`FÃ¶rvÃ¤ntat lÃ¤ngd ${expected}, fick ${actual.length}`);
                    }
                },
                toBeTruthy() {
                    if (!actual) {
                        throw new Error(`FÃ¶rvÃ¤ntat truthy vÃ¤rde, fick ${actual}`);
                    }
                },
                toBeFalsy() {
                    if (actual) {
                        throw new Error(`FÃ¶rvÃ¤ntat falsy vÃ¤rde, fick ${actual}`);
                    }
                },
                toMatch(regex) {
                    if (!regex.test(actual)) {
                        throw new Error(`FÃ¶rvÃ¤ntat att ${actual} matchar ${regex}`);
                    }
                }
            };
        }

        // =====================================================
        // Funktioner att testa (kopierade frÃ¥n app.js/creator.js)
        // =====================================================

        // FrÃ¥n app.js
        function getCardId(card) {
            return card.title;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Mock fÃ¶r collections (anvÃ¤nds av isInCollection)
        let collections = {};

        function isInCollection(card, collectionId) {
            if (!collections[collectionId]) return false;
            return collections[collectionId].cards.includes(getCardId(card));
        }

        // Mock fÃ¶r cards
        let cards = [];

        function getCollectionCards(collectionId) {
            if (!collections[collectionId]) return [];
            return cards.filter(card => isInCollection(card, collectionId));
        }

        const FAVORITES_ID = 'favorites';

        function isFavorite(card) {
            return isInCollection(card, FAVORITES_ID);
        }

        // FrÃ¥n creator.js - CSV/TSV parser
        function parseLine(line, delimiter) {
            const fields = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === delimiter && !inQuotes) {
                    fields.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            fields.push(current);

            return fields;
        }

        function parseDelimitedText(text) {
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length === 0) return [];

            // Detect delimiter: if first line has tabs, use tab; otherwise use comma
            const firstLine = lines[0];
            const delimiter = firstLine.includes('\t') ? '\t' : ',';

            const cards = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                if (i === 0 && line.toLowerCase().includes('category')) {
                    continue;
                }

                const fields = parseLine(line, delimiter);

                if (fields.length >= 4) {
                    cards.push({
                        category: fields[0].trim(),
                        icon: fields[1].trim(),
                        title: fields[2].trim(),
                        description: fields[3].trim()
                    });
                }
            }

            return cards;
        }

        function adjustColor(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const r = Math.min(255, Math.max(0, (num >> 16) + percent));
            const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + percent));
            const b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
            return '#' + (0x1000000 + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // =====================================================
        // TESTER
        // =====================================================

        describe('getCardId', () => {
            it('ska returnera kortets titel som ID', () => {
                const card = { title: 'Test Kort', description: 'En beskrivning' };
                expect(getCardId(card)).toBe('Test Kort');
            });

            it('ska hantera kort med specialtecken i titeln', () => {
                const card = { title: 'Kort med Ã¥Ã¤Ã¶ & tecken!', description: '' };
                expect(getCardId(card)).toBe('Kort med Ã¥Ã¤Ã¶ & tecken!');
            });
        });

        describe('shuffleArray', () => {
            it('ska behÃ¥lla samma lÃ¤ngd efter blandning', () => {
                const arr = [1, 2, 3, 4, 5];
                const shuffled = shuffleArray([...arr]);
                expect(shuffled).toHaveLength(5);
            });

            it('ska behÃ¥lla samma element efter blandning', () => {
                const arr = [1, 2, 3, 4, 5];
                const shuffled = shuffleArray([...arr]);
                expect(shuffled.sort()).toEqual([1, 2, 3, 4, 5]);
            });

            it('ska returnera samma array (muterad)', () => {
                const arr = [1, 2, 3];
                const result = shuffleArray(arr);
                expect(result).toBe(arr);
            });

            it('ska hantera tom array', () => {
                const arr = [];
                const shuffled = shuffleArray(arr);
                expect(shuffled).toHaveLength(0);
            });

            it('ska hantera array med ett element', () => {
                const arr = [42];
                const shuffled = shuffleArray(arr);
                expect(shuffled).toEqual([42]);
            });
        });

        describe('isInCollection', () => {
            it('ska returnera false om samlingen inte finns', () => {
                collections = {};
                const card = { title: 'Kort 1' };
                expect(isInCollection(card, 'nonexistent')).toBeFalsy();
            });

            it('ska returnera true om kortet finns i samlingen', () => {
                collections = { 'col1': { name: 'Samling', cards: ['Kort 1', 'Kort 2'] } };
                const card = { title: 'Kort 1' };
                expect(isInCollection(card, 'col1')).toBeTruthy();
            });

            it('ska returnera false om kortet inte finns i samlingen', () => {
                collections = { 'col1': { name: 'Samling', cards: ['Kort 2'] } };
                const card = { title: 'Kort 1' };
                expect(isInCollection(card, 'col1')).toBeFalsy();
            });
        });

        describe('getCollectionCards', () => {
            it('ska returnera tom array om samlingen inte finns', () => {
                collections = {};
                cards = [{ title: 'Kort 1' }];
                expect(getCollectionCards('nonexistent')).toEqual([]);
            });

            it('ska returnera kort som finns i samlingen', () => {
                cards = [
                    { title: 'Kort 1', category: 'A' },
                    { title: 'Kort 2', category: 'B' },
                    { title: 'Kort 3', category: 'A' }
                ];
                collections = { 'col1': { name: 'Samling', cards: ['Kort 1', 'Kort 3'] } };
                const result = getCollectionCards('col1');
                expect(result).toHaveLength(2);
                expect(result[0].title).toBe('Kort 1');
                expect(result[1].title).toBe('Kort 3');
            });
        });

        describe('isFavorite', () => {
            it('ska returnera false om favoriter inte finns', () => {
                collections = {};
                const card = { title: 'Kort 1' };
                expect(isFavorite(card)).toBeFalsy();
            });

            it('ska returnera true om kortet Ã¤r en favorit', () => {
                collections = { 'favorites': { name: 'Favoriter', cards: ['Kort 1'] } };
                const card = { title: 'Kort 1' };
                expect(isFavorite(card)).toBeTruthy();
            });
        });

        describe('parseLine (CSV)', () => {
            it('ska parsa enkel CSV-rad', () => {
                const line = 'a,b,c,d';
                expect(parseLine(line, ',')).toEqual(['a', 'b', 'c', 'd']);
            });

            it('ska hantera citerade fÃ¤lt med kommatecken', () => {
                const line = 'kategori,ikon,"titel, med komma",beskrivning';
                const result = parseLine(line, ',');
                expect(result[2]).toBe('titel, med komma');
            });

            it('ska hantera tomma fÃ¤lt', () => {
                const line = 'a,,c,d';
                expect(parseLine(line, ',')).toEqual(['a', '', 'c', 'd']);
            });

            it('ska hantera citerade fÃ¤lt med flera kommatecken', () => {
                const line = '"a,b,c",d,e,f';
                const result = parseLine(line, ',');
                expect(result[0]).toBe('a,b,c');
            });
        });

        describe('parseLine (TSV)', () => {
            it('ska parsa enkel TSV-rad', () => {
                const line = 'a\tb\tc\td';
                expect(parseLine(line, '\t')).toEqual(['a', 'b', 'c', 'd']);
            });

            it('ska hantera kommatecken i TSV utan citattecken', () => {
                const line = 'kategori\tikon\ttitel, med komma\tbeskrivning';
                const result = parseLine(line, '\t');
                expect(result[2]).toBe('titel, med komma');
            });
        });

        describe('parseDelimitedText (CSV)', () => {
            it('ska parsa CSV-text till kort-objekt', () => {
                const csv = 'Kategori,Ikon,Titel,Beskrivning';
                const result = parseDelimitedText(csv);
                expect(result).toHaveLength(1);
                expect(result[0].category).toBe('Kategori');
                expect(result[0].title).toBe('Titel');
            });

            it('ska hoppa Ã¶ver header-rad', () => {
                const csv = `category,icon,title,description
Andning,ðŸŒ¬ï¸,Djupandning,Andas djupt`;
                const result = parseDelimitedText(csv);
                expect(result).toHaveLength(1);
                expect(result[0].category).toBe('Andning');
            });

            it('ska hantera flera rader', () => {
                const csv = `A,1,Kort1,Besk1
B,2,Kort2,Besk2
C,3,Kort3,Besk3`;
                const result = parseDelimitedText(csv);
                expect(result).toHaveLength(3);
            });

            it('ska trimma whitespace', () => {
                const csv = '  Kategori  ,  Ikon  ,  Titel  ,  Beskrivning  ';
                const result = parseDelimitedText(csv);
                expect(result[0].category).toBe('Kategori');
                expect(result[0].title).toBe('Titel');
            });

            it('ska ignorera rader med fÃ¶r fÃ¥ fÃ¤lt', () => {
                const csv = `A,B,C,D
X,Y,Z`;
                const result = parseDelimitedText(csv);
                expect(result).toHaveLength(1);
            });

            it('ska hantera tomma rader', () => {
                const csv = `A,B,C,D

X,Y,Z,W`;
                const result = parseDelimitedText(csv);
                expect(result).toHaveLength(2);
            });
        });

        describe('parseDelimitedText (TSV)', () => {
            it('ska parsa TSV-text till kort-objekt', () => {
                const tsv = 'Kategori\tIkon\tTitel\tBeskrivning';
                const result = parseDelimitedText(tsv);
                expect(result).toHaveLength(1);
                expect(result[0].category).toBe('Kategori');
                expect(result[0].title).toBe('Titel');
            });

            it('ska hoppa Ã¶ver TSV header-rad', () => {
                const tsv = `category\ticon\ttitle\tdescription
Andning\tðŸŒ¬ï¸\tDjupandning\tAndas djupt`;
                const result = parseDelimitedText(tsv);
                expect(result).toHaveLength(1);
                expect(result[0].category).toBe('Andning');
            });

            it('ska hantera kommatecken i TSV-fÃ¤lt', () => {
                const tsv = 'Kategori\tIkon\tTitel, med komma\tBeskrivning, med komma';
                const result = parseDelimitedText(tsv);
                expect(result[0].title).toBe('Titel, med komma');
                expect(result[0].description).toBe('Beskrivning, med komma');
            });
        });

        // Valideringsfunktioner (frÃ¥n creator.js/admin.js)
        function isValidDeckId(deckId) {
            return /^[a-z0-9-]+$/.test(deckId);
        }

        function isValidEmail(email) {
            return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
        }

        function isValidPassword(password) {
            return password && password.length >= 6;
        }

        function isValidHexColor(hex) {
            return /^#[0-9a-fA-F]{6}$/.test(hex);
        }

        function generateGradient(baseColor) {
            const darkened = adjustColor(baseColor, -20);
            return `linear-gradient(135deg, ${baseColor} 0%, ${darkened} 100%)`;
        }

        // =====================================================
        // NYA TESTER
        // =====================================================

        describe('isValidDeckId', () => {
            it('ska godkÃ¤nna giltigt deck-ID med smÃ¥ bokstÃ¤ver', () => {
                expect(isValidDeckId('minlek')).toBeTruthy();
            });

            it('ska godkÃ¤nna deck-ID med siffror', () => {
                expect(isValidDeckId('lek123')).toBeTruthy();
            });

            it('ska godkÃ¤nna deck-ID med bindestreck', () => {
                expect(isValidDeckId('min-kortlek-2024')).toBeTruthy();
            });

            it('ska avvisa deck-ID med stora bokstÃ¤ver', () => {
                expect(isValidDeckId('MinLek')).toBeFalsy();
            });

            it('ska avvisa deck-ID med mellanslag', () => {
                expect(isValidDeckId('min lek')).toBeFalsy();
            });

            it('ska avvisa deck-ID med specialtecken', () => {
                expect(isValidDeckId('min_lek!')).toBeFalsy();
            });

            it('ska avvisa deck-ID med svenska tecken', () => {
                expect(isValidDeckId('minÃ¥Ã¤Ã¶lek')).toBeFalsy();
            });

            it('ska avvisa tom strÃ¤ng', () => {
                expect(isValidDeckId('')).toBeFalsy();
            });
        });

        describe('isValidEmail', () => {
            it('ska godkÃ¤nna giltig e-postadress', () => {
                expect(isValidEmail('test@example.com')).toBeTruthy();
            });

            it('ska godkÃ¤nna e-post med subdomÃ¤n', () => {
                expect(isValidEmail('user@mail.example.com')).toBeTruthy();
            });

            it('ska godkÃ¤nna e-post med siffror', () => {
                expect(isValidEmail('user123@test456.se')).toBeTruthy();
            });

            it('ska godkÃ¤nna e-post med punkt fÃ¶re @', () => {
                expect(isValidEmail('first.last@example.com')).toBeTruthy();
            });

            it('ska avvisa e-post utan @', () => {
                expect(isValidEmail('testexample.com')).toBeFalsy();
            });

            it('ska avvisa e-post utan domÃ¤n', () => {
                expect(isValidEmail('test@')).toBeFalsy();
            });

            it('ska avvisa e-post utan anvÃ¤ndarnamn', () => {
                expect(isValidEmail('@example.com')).toBeFalsy();
            });

            it('ska avvisa e-post med mellanslag', () => {
                expect(isValidEmail('test @example.com')).toBeFalsy();
            });

            it('ska avvisa tom strÃ¤ng', () => {
                expect(isValidEmail('')).toBeFalsy();
            });
        });

        describe('isValidPassword', () => {
            it('ska godkÃ¤nna lÃ¶senord med 6 tecken', () => {
                expect(isValidPassword('123456')).toBeTruthy();
            });

            it('ska godkÃ¤nna lÃ¶senord med fler Ã¤n 6 tecken', () => {
                expect(isValidPassword('mittlÃ¥ngalÃ¶senord')).toBeTruthy();
            });

            it('ska avvisa lÃ¶senord med 5 tecken', () => {
                expect(isValidPassword('12345')).toBeFalsy();
            });

            it('ska avvisa tomt lÃ¶senord', () => {
                expect(isValidPassword('')).toBeFalsy();
            });

            it('ska avvisa null', () => {
                expect(isValidPassword(null)).toBeFalsy();
            });

            it('ska avvisa undefined', () => {
                expect(isValidPassword(undefined)).toBeFalsy();
            });
        });

        describe('isValidHexColor', () => {
            it('ska godkÃ¤nna giltig hex-fÃ¤rg med #', () => {
                expect(isValidHexColor('#ff0000')).toBeTruthy();
            });

            it('ska godkÃ¤nna hex-fÃ¤rg med stora bokstÃ¤ver', () => {
                expect(isValidHexColor('#FF00AA')).toBeTruthy();
            });

            it('ska godkÃ¤nna hex-fÃ¤rg med blandade bokstÃ¤ver', () => {
                expect(isValidHexColor('#aAbBcC')).toBeTruthy();
            });

            it('ska avvisa hex-fÃ¤rg utan #', () => {
                expect(isValidHexColor('ff0000')).toBeFalsy();
            });

            it('ska avvisa kort hex-fÃ¤rg (3 tecken)', () => {
                expect(isValidHexColor('#f00')).toBeFalsy();
            });

            it('ska avvisa fÃ¶r lÃ¥ng hex-fÃ¤rg', () => {
                expect(isValidHexColor('#ff00001')).toBeFalsy();
            });

            it('ska avvisa ogiltiga tecken', () => {
                expect(isValidHexColor('#gggggg')).toBeFalsy();
            });
        });

        describe('generateGradient', () => {
            it('ska generera en giltig gradient-strÃ¤ng', () => {
                const result = generateGradient('#669e6a');
                expect(result).toContain('linear-gradient');
                expect(result).toContain('#669e6a');
                expect(result).toContain('135deg');
            });

            it('ska inkludera mÃ¶rkare fÃ¤rg i slutet', () => {
                const result = generateGradient('#ffffff');
                expect(result).toContain('#ebebeb');
            });

            it('ska ha korrekt format', () => {
                const result = generateGradient('#808080');
                expect(result).toMatch(/^linear-gradient\(135deg, #[0-9a-f]{6} 0%, #[0-9a-f]{6} 100%\)$/);
            });
        });

        describe('adjustColor', () => {
            it('ska gÃ¶ra en fÃ¤rg mÃ¶rkare med negativt vÃ¤rde', () => {
                const result = adjustColor('#ffffff', -20);
                expect(result).toBe('#ebebeb');
            });

            it('ska gÃ¶ra en fÃ¤rg ljusare med positivt vÃ¤rde', () => {
                const result = adjustColor('#000000', 20);
                expect(result).toBe('#141414');
            });

            it('ska inte gÃ¥ under 0', () => {
                const result = adjustColor('#000000', -50);
                expect(result).toBe('#000000');
            });

            it('ska inte gÃ¥ Ã¶ver 255', () => {
                const result = adjustColor('#ffffff', 50);
                expect(result).toBe('#ffffff');
            });

            it('ska hantera fÃ¤rger utan #', () => {
                const result = adjustColor('669e6a', -20);
                expect(result).toMatch(/^#[0-9a-f]{6}$/);
            });

            it('ska justera alla RGB-kanaler', () => {
                const result = adjustColor('#808080', -16);
                expect(result).toBe('#707070');
            });
        });

        // =====================================================
        // Rendera resultat
        // =====================================================

        function renderResults() {
            const resultsDiv = document.getElementById('results');
            let html = '';
            let currentSuite = '';

            tests.forEach(test => {
                if (test.type === 'suite') {
                    if (currentSuite) html += '</div>';
                    html += `<div class="test-suite"><h2>${test.name}</h2>`;
                    currentSuite = test.name;
                } else {
                    html += `
                        <div class="test ${test.pass ? 'pass' : 'fail'}">
                            <span>${test.pass ? 'âœ“' : 'âœ—'} ${test.name}</span>
                            ${test.error ? `<div class="error-msg">${test.error}</div>` : ''}
                        </div>
                    `;
                }
            });
            if (currentSuite) html += '</div>';

            resultsDiv.innerHTML = html;

            const summaryDiv = document.getElementById('summary');
            const allPass = failed === 0;
            summaryDiv.innerHTML = `
                <div class="summary ${allPass ? 'all-pass' : 'has-fail'}">
                    ${allPass ? 'âœ“ Alla tester passerade!' : `âœ— ${failed} test${failed > 1 ? 'er' : ''} misslyckades`}
                    (${passed} av ${passed + failed} lyckades)
                </div>
            `;
        }

        renderResults();
    </script>
</body>
</html>
